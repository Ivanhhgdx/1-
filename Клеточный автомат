<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Emergence Lab — single-file MVP</title>
<style>
  :root{
    --bg:#0b0f14;
    --panel:#0f1722cc;
    --card:#121b28cc;
    --text:#dfe7ee;
    --muted:#9bb0c3;
    --accent:#5cc8ff;
    --accent2:#b46bff;
    --good:#5CFF95;
    --warn:#ffd166;
    --danger:#ff6b6b;
    --glass:rgba(255,255,255,0.06);
    --blur:14px;
    --radius:16px;
    --shadow:0 10px 30px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.05);
  }
  *{box-sizing:border-box}
  html,body{height:100%;background:radial-gradient(1200px 800px at 10% 0%,#0b1220,transparent),
                         radial-gradient(800px 600px at 90% 100%,#120f1f,transparent),var(--bg);
            color:var(--text);font:15px/1.4 ui-sans-serif,system-ui,Segoe UI,Roboto,Inter,Arial}
  #app{display:grid;grid-template-columns:300px 1fr;grid-template-rows:auto 1fr auto;height:100vh;gap:14px;padding:14px}
  header,aside,main,footer{backdrop-filter:saturate(130%) blur(var(--blur));border-radius:var(--radius);box-shadow:var(--shadow)}
  header{grid-column:1/3;display:flex;align-items:center;justify-content:space-between;padding:10px 14px;background:linear-gradient(180deg,var(--card),var(--panel));border:1px solid #1a2636}
  header .title{display:flex;gap:12px;align-items:center}
  .logo{width:28px;height:28px;border-radius:8px;background:conic-gradient(from 120deg,var(--accent),var(--accent2),var(--good),var(--accent));box-shadow:0 0 24px #5cc8ff55}
  .title h1{margin:0;font-size:16px;letter-spacing:.3px}
  .chips{display:flex;gap:8px;flex-wrap:wrap}
  .chip{padding:6px 10px;border-radius:999px;background:linear-gradient(180deg,#142033,#0b1320);border:1px solid #1b2a40;color:var(--muted)}
  aside{padding:12px;background:linear-gradient(180deg,var(--card),#0f1522);border:1px solid #1b2638;display:flex;flex-direction:column;gap:12px;min-height:0}
  .section h3{margin:4px 0 8px;font-size:12px;letter-spacing:.6px;color:#a9bed1;text-transform:uppercase}
  .list{display:grid;gap:8px;grid-auto-rows:min-content;overflow:auto;padding-right:2px}
  .card{padding:10px;border-radius:12px;background:linear-gradient(180deg,#0e1624,#0b121e);border:1px solid #1a2a3f;cursor:pointer;transition:transform .06s ease, border .2s}
  .card:hover{transform:translateY(-1px);border-color:#274366}
  .card.active{border-color:var(--accent);box-shadow:0 0 0 1px #5cc8ff55 inset}
  .card small{display:block;color:var(--muted);opacity:.9}
  .toolbar{display:flex;gap:8px;flex-wrap:wrap}
  .btn{border:1px solid #1a2a3f;background:linear-gradient(180deg,#122033,#0c1726);padding:8px 10px;border-radius:10px;color:var(--text);cursor:pointer;transition:transform .06s ease,border .2s}
  .btn:hover{transform:translateY(-1px);border-color:#2a4a72}
  .btn.primary{border-color:#235a80;background:linear-gradient(180deg,#0c2031,#0e263b);box-shadow:0 0 0 1px #5cc8ff33 inset}
  .btn.warn{border-color:#5a3c00}
  .btn.ghost{background:transparent}
  .row{display:flex;gap:8px;align-items:center}
  label{font-size:12px;color:#adbed0}
  input[type="range"]{width:100%}
  input[type="text"],select{width:100%;background:#0b1421;border:1px solid #1b2a3c;color:var(--text);padding:8px;border-radius:10px}
  main{position:relative;display:grid;grid-template-rows:1fr auto;background:linear-gradient(180deg,var(--panel),#0d1421);border:1px solid #1a2a3f;overflow:hidden}
  #canvasWrap{position:relative}
  canvas{display:block;width:100%;height:100%}
  .overlay{position:absolute;inset:0;pointer-events:none}
  .hud{position:absolute;left:10px;top:10px;padding:8px 10px;border-radius:12px;background:linear-gradient(180deg,#0b121d,#0b121dcc);border:1px solid #1a2638;color:#9fb4c6;font-size:12px}
  .badge{padding:2px 6px;border-radius:999px;background:#112033;border:1px solid #1f324b;margin-left:6px}
  footer{grid-column:1/3;padding:10px;background:linear-gradient(180deg,#0f1522,#0c111c);border:1px solid #182537;display:flex;gap:12px;flex-wrap:wrap;align-items:center;justify-content:space-between}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .paramGrid{display:grid;grid-template-columns:repeat(6,minmax(120px,1fr));gap:10px}
  @media (max-width:1100px){#app{grid-template-columns:1fr} aside{order:3} footer{order:4}}
  /* micro-anim */
  .pulse{animation:pulse 1.8s ease-in-out infinite}
  @keyframes pulse{0%{box-shadow:0 0 0 0 #5cc8ff44}70%{box-shadow:0 0 0 12px transparent}100%{box-shadow:0 0 0 0 transparent}}
</style>
</head>
<body>
<div id="app">
  <header>
    <div class="title">
      <div class="logo pulse"></div>
      <h1>Emergence Lab <span class="badge" id="simBadge">Загрузка…</span></h1>
    </div>
    <div class="chips">
      <div class="chip">Пауза/Пробел</div>
      <div class="chip">Пинч/Зум • Панорамирование</div>
      <div class="chip">Экспорт PNG</div>
      <div class="chip">Пресеты</div>
    </div>
  </header>

  <aside>
    <div class="section">
      <h3>Сцены</h3>
      <div class="list" id="sceneList"></div>
    </div>
    <div class="section">
      <h3>Пресеты</h3>
      <div class="row">
        <select id="presetSelect"></select>
        <button class="btn" id="applyPreset">Применить</button>
      </div>
      <div class="row" style="margin-top:8px">
        <button class="btn" id="savePreset">Сохранить</button>
        <button class="btn ghost" id="copyPreset">Копия в буфер</button>
      </div>
      <textarea id="presetJson" rows="6" style="margin-top:8px;width:100%;background:#0b1421;border:1px solid #1b2a3c;color:#a9bed1;border-radius:10px;padding:8px" placeholder="JSON пресета"></textarea>
    </div>
  </aside>

  <main>
    <div id="canvasWrap">
      <canvas id="view"></canvas>
      <div class="overlay">
        <div class="hud" id="hud">FPS: <span id="fps">0</span> • Частицы: <span id="statA">0</span> • Тик: <span id="tick">0</span></div>
      </div>
    </div>
    <div style="padding:10px;border-top:1px solid #1a2a3f;background:linear-gradient(180deg,#0d1421,#0b121c)">
      <div class="toolbar" style="margin-bottom:10px">
        <button class="btn primary" id="playPause">Пауза</button>
        <button class="btn" id="step">Шаг</button>
        <button class="btn" id="reset">Сброс</button>
        <button class="btn" id="exportPng">PNG</button>
        <div class="row" style="gap:14px;margin-left:auto">
          <label>Скорость <span id="speedLbl">1.0x</span></label>
          <input type="range" min="0.1" max="3" step="0.1" value="1" id="speed">
          <label>Зум</label>
          <input type="range" min="0.2" max="4" step="0.1" value="1" id="zoom">
        </div>
      </div>
      <div class="paramGrid" id="paramGrid"></div>
    </div>
  </main>

  <footer>
    <div class="controls">
      <span style="color:#9bb0c3">Готовый MVP. Режимы: Клеточный автомат, Boids, Реакция-диффузия, Песчаная куча, Рынок.</span>
    </div>
    <div class="controls">
      <span style="color:#9bb0c3">© Emergence Lab</span>
    </div>
  </footer>
</div>

<script>
(() => {
  const $ = (q) => document.querySelector(q);
  const el = {
    canvas: $('#view'),
    sceneList: $('#sceneList'),
    paramGrid: $('#paramGrid'),
    playPause: $('#playPause'),
    step: $('#step'),
    reset: $('#reset'),
    exportPng: $('#exportPng'),
    speed: $('#speed'),
    speedLbl: $('#speedLbl'),
    zoom: $('#zoom'),
    fps: $('#fps'),
    statA: $('#statA'),
    tick: $('#tick'),
    presetSelect: $('#presetSelect'),
    presetJson: $('#presetJson'),
    applyPreset: $('#applyPreset'),
    savePreset: $('#savePreset'),
    copyPreset: $('#copyPreset'),
    simBadge: $('#simBadge'),
    canvasWrap: $('#canvasWrap')
  };

  // Canvas sizing
  const ctx = el.canvas.getContext('2d');
  let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  const resize = () => {
    const r = el.canvas.getBoundingClientRect();
    el.canvas.width = Math.floor(r.width * DPR);
    el.canvas.height = Math.floor(r.height * DPR);
  };
  const ro = new ResizeObserver(resize);
  ro.observe(el.canvas);

  // Camera / pan / zoom
  const camera = {x:0,y:0,zoom:1};
  el.zoom.addEventListener('input', () => {
    camera.zoom = parseFloat(el.zoom.value);
  });
  let isPanning=false, panStart={x:0,y:0}, camStart={x:0,y:0};
  el.canvas.addEventListener('mousedown', e=>{
    isPanning=true; panStart={x:e.clientX,y:e.clientY}; camStart={x:camera.x,y:camera.y};
  });
  window.addEventListener('mouseup', ()=>isPanning=false);
  window.addEventListener('mousemove', e=>{
    if(!isPanning) return;
    camera.x = camStart.x + (e.clientX - panStart.x)/camera.zoom*DPR;
    camera.y = camStart.y + (e.clientY - panStart.y)/camera.zoom*DPR;
  });
  // Touch: pan + pinch
  let touches = [];
  const getDist = (a,b)=>Math.hypot(a.clientX-b.clientX,a.clientY-b.clientY);
  el.canvas.addEventListener('touchstart', e=>{
    touches = [...e.touches];
    if(touches.length===1){
      isPanning=true; panStart={x:touches[0].clientX,y:touches[0].clientY}; camStart={x:camera.x,y:camera.y};
    }
  },{passive:true});
  el.canvas.addEventListener('touchmove', e=>{
    if(e.touches.length===1 && isPanning){
      const t=e.touches[0];
      camera.x = camStart.x + (t.clientX - panStart.x)/camera.zoom*DPR;
      camera.y = camStart.y + (t.clientY - panStart.y)/camera.zoom*DPR;
    } else if(e.touches.length===2 && touches.length===2){
      const d0=getDist(touches[0],touches[1]);
      const d1=getDist(e.touches[0],e.touches[1]);
      const scale = d1/d0;
      camera.zoom = Math.min(4, Math.max(0.2, camera.zoom*scale));
      el.zoom.value = camera.zoom.toFixed(2);
      touches=[...e.touches];
    }
  },{passive:true});
  el.canvas.addEventListener('touchend', ()=>{isPanning=false; touches=[]},{passive:true});
  el.canvas.addEventListener('wheel', e=>{
    const delta = Math.sign(e.deltaY)*-0.05;
    camera.zoom = Math.min(4, Math.max(0.2, camera.zoom*(1+delta)));
    el.zoom.value = camera.zoom.toFixed(2);
  },{passive:true});

  // Utilities
  const rand = (a,b)=>a+Math.random()*(b-a);
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

  // Base simulation scaffold
  class Sim {
    constructor(name){ this.name=name; this.tick=0; this.statsA=0; this.params=[]; }
    init(){}; step(dt){}; draw(){}; reset(){}; getPreset(){ return {}; } setPreset(_) {}
    ui(){ return []; } // [{key,label,type,min,max,step}, ...]
  }

  // 1) Game of Life (configurable B/S)
  class LifeSim extends Sim{
    constructor(){ super('Клеточный автомат'); }
    init(){
      this.w=160; this.h=100;
      this.grid=new Uint8Array(this.w*this.h);
      for(let i=0;i<this.grid.length;i++) this.grid[i]=(Math.random()<0.15)?1:0;
      this.rule="B3/S23";
      this.wrap=true;
      this.color="#5cc8ff";
      this.tick=0;
    }
    idx(x,y){
      if(this.wrap){
        x=(x+this.w)%this.w; y=(y+this.h)%this.h;
      }else{
        if(x<0||y<0||x>=this.w||y>=this.h) return -1;
      }
      return y*this.w+x;
    }
    parseRule(){
      const [b,s]=this.rule.toUpperCase().split('/').map(t=>t.replace(/[BS]/g,''));
      this.birth=new Set([...b].map(n=>+n));
      this.surv=new Set([...s].map(n=>+n));
    }
    reset(){ this.init(); this.parseRule(); }
    setPreset(p){
      this.rule=p.rule??this.rule; this.wrap=!!p.wrap; this.color=p.color||this.color;
      if(p.seed) this.randomSeed(p.seed);
      this.parseRule();
    }
    randomSeed(seed){
      let s=seed>>>0;
      const rng=()=> (s=s*1664525+1013904223>>>0)/4294967296;
      for(let i=0;i<this.grid.length;i++) this.grid[i]=(rng()<0.15)?1:0;
    }
    ui(){
      return [
        {key:'rule', label:'Правило B/S', type:'text'},
        {key:'wrap', label:'Тороид', type:'bool'},
        {key:'color', label:'Цвет', type:'color'},
        {key:'rand', label:'Пересев', type:'button'}
      ];
    }
    step(dt){
      if(!this.birth) this.parseRule();
      const next=new Uint8Array(this.grid.length);
      const dirs=[-1,-1, 0,-1, 1,-1, -1,0, 1,0, -1,1, 0,1, 1,1];
      for(let y=0;y<this.h;y++){
        for(let x=0;x<this.w;x++){
          const i=y*this.w+x;
          let n=0;
          for(let k=0;k<16;k+=2){
            const j=this.idx(x+dirs[k], y+dirs[k+1]);
            if(j>=0) n+=this.grid[j];
          }
          const alive=this.grid[i]===1;
          next[i] = alive ? (this.surv.has(n)?1:0) : (this.birth.has(n)?1:0);
        }
      }
      this.grid=next;
      this.tick++;
      this.statsA=next.reduce((a,b)=>a+b,0);
    }
    draw(){
      const cw = (el.canvas.width)/this.w*camera.zoom;
      const ch = (el.canvas.height)/this.h*camera.zoom;
      ctx.save();
      ctx.clearRect(0,0,el.canvas.width,el.canvas.height);
      ctx.translate(-camera.x*camera.zoom,-camera.y*camera.zoom);
      ctx.fillStyle=this.color;
      for(let y=0;y<this.h;y++){
        for(let x=0;x<this.w;x++){
          if(this.grid[y*this.w+x]){
            ctx.fillRect(x*cw,y*ch,cw,ch);
          }
        }
      }
      ctx.restore();
    }
  }

  // 2) Boids (flocking)
  class BoidsSim extends Sim{
    constructor(){ super('Boids стая'); }
    init(){
      this.n=600; this.sep=24; this.ali=55; this.coh=60; this.maxv=2.6; this.perc=80; this.jitter=0.2;
      this.w=el.canvas.width; this.h=el.canvas.height;
      this.boids=new Float32Array(this.n*4); // x,y, vx,vy
      for(let i=0;i<this.n;i++){
        const k=i*4;
        this.boids[k]=rand(0,this.w); this.boids[k+1]=rand(0,this.h);
        const a=rand(0,Math.PI*2); const v=rand(0.5,1.5);
        this.boids[k+2]=Math.cos(a)*v; this.boids[k+3]=Math.sin(a)*v;
      }
      this.tick=0;
    }
    ui(){
      return [
        {key:'n',label:'Число агентов',type:'range',min:100,max:1500,step:50},
        {key:'sep',label:'Разделение',type:'range',min:6,max:80,step:1},
        {key:'ali',label:'Выравнивание',type:'range',min:10,max:120,step:1},
        {key:'coh',label:'Притяжение',type:'range',min:10,max:200,step:1},
        {key:'maxv',label:'Макс. скорость',type:'range',min:0.6,max:6,step:0.1},
        {key:'perc',label:'Радиус восприятия',type:'range',min:20,max:200,step:1},
        {key:'jitter',label:'Шум',type:'range',min:0,max:1,step:0.01},
      ];
    }
    reset(){ this.init(); }
    step(dt){
      const n=this.n, b=this.boids, perc=this.perc, sep=this.sep, ali=this.ali, coh=this.coh;
      for(let i=0;i<n;i++){
        const k=i*4; let x=b[k], y=b[k+1], vx=b[k+2], vy=b[k+3];
        let cx=0, cy=0, vxm=0, vym=0, sepX=0, sepY=0, cnt=0;
        for(let j=0;j<n;j++){
          if(i===j) continue;
          const m=j*4; const dx=b[m]-x; const dy=b[m+1]-y; const d2=dx*dx+dy*dy;
          if(d2<perc*perc){
            cnt++;
            cx+=b[m]; cy+=b[m+1];
            vxm+=b[m+2]; vym+=b[m+3];
            if(d2<sep*sep){ sepX-=dx; sepY-=dy; }
          }
        }
        if(cnt>0){
          cx/=cnt; cy/=cnt; vxm/=cnt; vym/=cnt;
          vx += (vxm - vx)/ali + (cx - x)/coh + sepX*0.02;
          vy += (vym - vy)/ali + (cy - y)/coh + sepY*0.02;
        }
        // jitter
        vx += (Math.random()-0.5)*this.jitter;
        vy += (Math.random()-0.5)*this.jitter;
        // limit
        const v=Math.hypot(vx,vy); const m=this.maxv;
        if(v>m){ vx=vx/v*m; vy=vy/v*m; }
        x+=vx; y+=vy;
        // wrap
        const W=el.canvas.width, H=el.canvas.height;
        if(x<0) x+=W; if(x>W) x-=W; if(y<0) y+=H; if(y>H) y-=H;
        b[k]=x; b[k+1]=y; b[k+2]=vx; b[k+3]=vy;
      }
      this.statsA=n; this.tick++;
    }
    draw(){
      ctx.clearRect(0,0,el.canvas.width,el.canvas.height);
      ctx.save(); ctx.translate(-camera.x*camera.zoom,-camera.y*camera.zoom); ctx.scale(camera.zoom,camera.zoom);
      ctx.lineWidth=1*DPR; ctx.strokeStyle="#b46bff"; ctx.fillStyle="#5cc8ff";
      const b=this.boids;
      for(let i=0;i<this.n;i++){
        const k=i*4; const x=b[k], y=b[k+1]; const vx=b[k+2], vy=b[k+3];
        const ang=Math.atan2(vy,vx);
        ctx.save(); ctx.translate(x,y); ctx.rotate(ang);
        ctx.beginPath(); ctx.moveTo(8,0); ctx.lineTo(-6,4); ctx.lineTo(-6,-4); ctx.closePath(); ctx.fill();
        ctx.restore();
      }
      ctx.restore();
    }
  }

  // 3) Reaction-Diffusion (Gray-Scott)
  class RDSim extends Sim{
    constructor(){ super('Реакция-диффузия'); }
    init(){
      this.w=200; this.h=120;
      const N=this.w*this.h;
      this.U=new Float32Array(N).fill(1);
      this.V=new Float32Array(N).fill(0);
      // Seed
      for(let y=50;y<70;y++) for(let x=80;x<120;x++) this.V[y*this.w+x]=1;
      this.Du=0.16; this.Dv=0.08; this.F=0.035; this.K=0.065; this.dt=1;
      this.tick=0;
    }
    ui(){
      return [
        {key:'F',label:'F',type:'range',min:0.0,max:0.08,step:0.001},
        {key:'K',label:'K',type:'range',min:0.0,max:0.08,step:0.001},
        {key:'Du',label:'Du',type:'range',min:0.01,max:0.4,step:0.01},
        {key:'Dv',label:'Dv',type:'range',min:0.01,max:0.4,step:0.01},
        {key:'dt',label:'Δt',type:'range',min:0.2,max:1.5,step:0.1},
        {key:'brush',label:'Кисть V',type:'range',min:0,max:1,step:0.05}
      ];
    }
    reset(){ this.init(); }
    step(){
      const {w,h,U,V,Du,Dv,F,K,dt}=this;
      const lap=(arr,x,y)=>{
        const i=y*w+x, L = (x>0?arr[i-1]:arr[i]), R=(x<w-1?arr[i+1]:arr[i]);
        const U1 = (y>0?arr[i-w]:arr[i]), D1=(y<h-1?arr[i+w]:arr[i]);
        return L+R+U1+D1 - 4*arr[i];
      };
      const n=U.length; const U2=new Float32Array(n), V2=new Float32Array(n);
      for(let y=0;y<h;y++){
        for(let x=0;x<w;x++){
          const i=y*w+x;
          const u=U[i], v=V[i];
          const du = Du*lap(U,x,y) - u*v*v + F*(1-u);
          const dv = Dv*lap(V,x,y) + u*v*v - (K+F)*v;
          U2[i]=clamp(u+du*dt,0,1); V2[i]=clamp(v+dv*dt,0,1);
        }
      }
      this.U=U2; this.V=V2; this.tick++;
      this.statsA = 0| (this.V.reduce((a,b)=>a+b,0)*100);
    }
    draw(){
      const {w,h,U,V}=this;
      const img = ctx.createImageData(w,h);
      for(let i=0;i<w*h;i++){
        const v=V[i]; const u=U[i];
        // palette
        const r = Math.floor(30 + 220*v);
        const g = Math.floor(200*Math.max(0,u-v));
        const b = Math.floor(255 - 220*u + 40*v);
        const k=i*4; img.data[k]=r; img.data[k+1]=g; img.data[k+2]=b; img.data[k+3]=255;
      }
      ctx.save();
      ctx.clearRect(0,0,el.canvas.width,el.canvas.height);
      ctx.translate(-camera.x*camera.zoom,-camera.y*camera.zoom);
      const scale = 3*camera.zoom;
      ctx.imageSmoothingEnabled=false;
      ctx.putImageData(img,0,0);
      ctx.scale(scale,scale);
      ctx.restore();
      // upscale draw
      ctx.save();
      ctx.translate(-camera.x*camera.zoom,-camera.y*camera.zoom);
      ctx.scale(el.canvas.width/(w)*camera.zoom, el.canvas.height/(h)*camera.zoom);
      ctx.drawImage(el.canvas,0,0);
      ctx.restore();
    }
  }

  // 4) Sandpile (Self-Organized Criticality)
  class SandSim extends Sim{
    constructor(){ super('Песчаная куча'); }
    init(){
      this.w=180; this.h=110; this.grid=new Uint16Array(this.w*this.h);
      this.addRate=250; // grains per tick
      this.tick=0;
    }
    ui(){
      return [
        {key:'addRate',label:'Добавление',type:'range',min:0,max:2000,step:10}
      ];
    }
    reset(){ this.init(); }
    topple(){
      const {w,h,grid}=this; let avalanches=0;
      const next=new Uint16Array(grid);
      for(let y=0;y<h;y++){
        for(let x=0;x<w;x++){
          const i=y*w+x;
          while(next[i]>=4){
            next[i]-=4; avalanches++;
            if(x>0) next[i-1]++;
            if(x<w-1) next[i+1]++;
            if(y>0) next[i-w]++;
            if(y<h-1) next[i+w]++;
          }
        }
      }
      this.grid=next; return avalanches;
    }
    step(){
      for(let k=0;k<this.addRate;k++){
        const x=(Math.random()*this.w)|0, y=(Math.random()*this.h)|0;
        this.grid[y*this.w+x]++;
      }
      const av = this.topple();
      this.statsA=av; this.tick++;
    }
    draw(){
      const {w,h,grid}=this;
      const img=ctx.createImageData(w,h);
      for(let i=0;i<w*h;i++){
        const v=grid[i]%4;
        const col = [
          [15,20,35],[90,120,220],[40,220,160],[250,200,90]
        ][v];
        const k=i*4; img.data[k]=col[0]; img.data[k+1]=col[1]; img.data[k+2]=col[2]; img.data[k+3]=255;
      }
      ctx.clearRect(0,0,el.canvas.width,el.canvas.height);
      ctx.save(); ctx.translate(-camera.x*camera.zoom,-camera.y*camera.zoom); ctx.scale(3*camera.zoom,3*camera.zoom);
      ctx.imageSmoothingEnabled=false; ctx.putImageData(img,0,0); ctx.restore();
    }
  }

  // 5) Toy Market (emergent price from simple strategies)
  class MarketSim extends Sim{
    constructor(){ super('Рынок агентов'); }
    init(){
      this.agents=200; this.fund=1000; this.stocks=10;
      this.price=100; this.cash=new Float32Array(this.agents).fill(this.fund);
      this.pos=new Float32Array(this.agents).fill(0);
      this.mood=0; // sentiment
      this.history = new Float32Array(600).fill(this.price);
      this.hidx=0;
      this.tick=0;
    }
    ui(){
      return [
        {key:'agents',label:'Агентов',type:'range',min:50,max:1000,step:50},
        {key:'fund',label:'Капитал',type:'range',min:100,max:5000,step:50},
        {key:'stocks',label:'Лимит позиций',type:'range',min:1,max:50,step:1},
        {key:'mood',label:'Сентимент',type:'range',min:-1,max:1,step:0.05}
      ];
    }
    reset(){ this.init(); }
    step(){
      const N=this.agents, price=this.price;
      let demand=0, supply=0;
      const trend = (this.history[this.hidx]-this.history[(this.hidx+1)%this.history.length]) || 0;
      for(let i=0;i<N;i++){
        // Simple heterogeneous strategies
        const type = i%4; // 0 trend-follow, 1 contrarian, 2 random, 3 value
        let desire=0;
        if(type===0) desire = Math.sign(trend + this.mood*0.3);
        if(type===1) desire = -Math.sign(trend);
        if(type===2) desire = Math.random()<0.5?1:-1;
        if(type===3){ const fair=100; desire = price<fair?1:-1; }
        // Constraints
        if(desire>0 && this.cash[i]>=price && this.pos[i]<this.stocks){ demand++; this.cash[i]-=price; this.pos[i]+=1; }
        if(desire<0 && this.pos[i]>0){ supply++; this.cash[i]+=price; this.pos[i]-=1; }
      }
      // Price adjust by imbalance
      const imbalance = demand - supply;
      const impact = 0.02 * Math.tanh(imbalance/Math.max(50, this.agents*0.1));
      this.price = clamp(this.price*(1+impact), 1, 10000);
      this.history[this.hidx]=this.price; this.hidx=(this.hidx+1)%this.history.length;
      this.statsA = (demand+supply)|0; this.tick++;
    }
    draw(){
      ctx.clearRect(0,0,el.canvas.width,el.canvas.height);
      ctx.save(); ctx.translate(18,0);
      // Price chart
      const W=el.canvas.width-36, H=el.canvas.height*0.66;
      ctx.strokeStyle="#5cc8ff"; ctx.lineWidth=2*DPR; ctx.beginPath();
      const min = Math.min(...this.history), max=Math.max(...this.history);
      const rng = Math.max(1e-6, max-min);
      for(let i=0;i<this.history.length;i++){
        const idx=(i+this.hidx)%this.history.length;
        const x = i/(this.history.length-1)*W;
        const y = H - (this.history[idx]-min)/rng*H;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      // Axes
      ctx.globalAlpha=0.6; ctx.strokeStyle="#1b2a3c"; ctx.beginPath();
      ctx.moveTo(0,H); ctx.lineTo(W,H); ctx.moveTo(0,0); ctx.lineTo(0,H); ctx.stroke(); ctx.globalAlpha=1;
      // Price label
      ctx.fillStyle="#b46bff"; ctx.font=`${14*DPR}px ui-sans-serif`; ctx.fillText(`Price: ${this.price.toFixed(2)}`, 6, 18*DPR);
      // Orderbook-ish bars (mock from last imbalance)
      const bars=20; const cx=0.5*W, bw=6*DPR;
      for(let i=0;i<bars;i++){
        const h = Math.sin((i+this.tick*0.1))*0.5+0.5;
        ctx.fillStyle=i%2? "#16304a":"#13273e"; ctx.fillRect(cx+i*bw, H+10, bw-1, h*60);
        ctx.fillRect(cx-(i+1)*bw, H+10, bw-1, (1-h)*60);
      }
      ctx.restore();
    }
  }

  // Registry
  const scenes = [
    new LifeSim(),
    new BoidsSim(),
    new RDSim(),
    new SandSim(),
    new MarketSim()
  ];

  // Presets
  const presets = {
    'Клеточный автомат: Классика': { sim:0, data:{rule:'B3/S23',wrap:true,color:'#5cc8ff'} },
    'Клеточный автомат: HighLife': { sim:0, data:{rule:'B36/S23',wrap:true,color:'#5CFF95'} },
    'Boids: Плотная стая': { sim:1, data:{n:900,perc:90,sep:22,ali:40,coh:70,jitter:0.12,maxv:2.8} },
    'Boids: Рой': { sim:1, data:{n:1200,perc:120,sep:12,jitter:0.35,maxv:3.2} },
    'RD: Пятна': { sim:2, data:{F:0.0367,K:0.0649,Du:0.16,Dv:0.08,dt:1} },
    'RD: Полосы': { sim:2, data:{F:0.02,K:0.055,Du:0.2,Dv:0.1,dt:1} },
    'Песок: Лавины': { sim:3, data:{addRate:1200} },
    'Рынок: Бык': { sim:4, data:{mood:0.6,agents:400} },
    'Рынок: Медведь': { sim:4, data:{mood:-0.5,agents:400} }
  };

  // UI builders
  function buildSceneList(){
    el.sceneList.innerHTML='';
    scenes.forEach((s,i)=>{
      const d=document.createElement('div');
      d.className='card'; d.innerHTML=`<strong>${s.name}</strong><small>id: ${i}</small>`;
      d.onclick=()=>selectScene(i);
      d.dataset.idx=i;
      el.sceneList.appendChild(d);
    });
  }
  function markActive(i){
    [...el.sceneList.children].forEach(c=>c.classList.toggle('active', +c.dataset.idx===i));
    el.simBadge.textContent = scenes[i].name;
  }
  function buildParams(sim){
    el.paramGrid.innerHTML='';
    const defs=sim.ui();
    defs.forEach(def=>{
      const wrap=document.createElement('div');
      wrap.className='card';
      let inner='';
      if(def.type==='range'){
        const v = sim[def.key] ?? 0;
        inner = `<label>${def.label}: <b id="lbl_${def.key}">${typeof v==='number'?v.toFixed(3).replace(/\.?0+$/,''):v}</b></label>
                 <input type="range" min="${def.min}" max="${def.max}" step="${def.step}" value="${v}" data-key="${def.key}">`;
      } else if(def.type==='text'){
        inner = `<label>${def.label}</label><input type="text" value="${sim[def.key]||''}" data-key="${def.key}">`;
      } else if(def.type==='bool'){
        inner = `<label><input type="checkbox" ${sim[def.key]?'checked':''} data-key="${def.key}"> ${def.label}</label>`;
      } else if(def.type==='color'){
        inner = `<label>${def.label}</label><input type="color" value="${sim[def.key]||'#ffffff'}" data-key="${def.key}">`;
      } else if(def.type==='button'){
        inner = `<button class="btn" data-key="${def.key}">${def.label}</button>`;
      }
      wrap.innerHTML=inner;
      el.paramGrid.appendChild(wrap);
    });
    // wiring
    el.paramGrid.querySelectorAll('input,button').forEach(control=>{
      control.oninput = (e)=>{
        const key=e.target.dataset.key;
        const def = defs.find(d=>d.key===key);
        if(def.type==='range'){
          const val=parseFloat(e.target.value);
          sim[key]=val;
          const lbl=document.getElementById('lbl_'+key);
          if(lbl) lbl.textContent = String(val.toFixed(3).replace(/\.?0+$/,''));
        }else if(def.type==='text'){ sim[key]=e.target.value; }
        else if(def.type==='bool'){ sim[key]=e.target.checked; }
        else if(def.type==='color'){ sim[key]=e.target.value; }
      };
      if(control.tagName==='BUTTON'){
        control.onclick = ()=>{
          const key=control.dataset.key;
          if(sim instanceof LifeSim && key==='rand'){ sim.randomSeed((Math.random()*1e9)|0); }
        };
      }
    });
  }
  function buildPresetSelect(){
    el.presetSelect.innerHTML='';
    Object.keys(presets).forEach(name=>{
      const o=document.createElement('option'); o.value=name; o.textContent=name; el.presetSelect.appendChild(o);
    });
  }

  // Scene management
  let current=0, sim=scenes[0];
  function selectScene(i){
    current=i; sim=scenes[i]; sim.reset(); markActive(i); buildParams(sim);
  }

  // Controls
  let running=true, speed=1;
  el.playPause.onclick=()=>{ running=!running; el.playPause.textContent=running?'Пауза':'Пуск'; };
  el.step.onclick=()=>{ stepFrame(1/60); };
  el.reset.onclick=()=>{ sim.reset(); };
  el.exportPng.onclick=()=>{
    const a=document.createElement('a');
    a.download=`emergence-${sim.name}-${Date.now()}.png`;
    a.href=el.canvas.toDataURL('image/png');
    a.click();
  };
  el.speed.oninput=()=>{ speed=parseFloat(el.speed.value); el.speedLbl.textContent=speed.toFixed(1)+'x'; };

  // Presets
  buildPresetSelect();
  el.applyPreset.onclick=()=>{
    const name=el.presetSelect.value; const p=presets[name];
    if(p){ selectScene(p.sim); sim.setPreset(p.data); buildParams(sim); el.presetJson.value=JSON.stringify(p,null,2); }
  };
  el.savePreset.onclick=()=>{
    const data={}; (sim.ui()).forEach(d=>{ if(d.type!=='button'){ data[d.key]=sim[d.key]; }});
    el.presetJson.value = JSON.stringify({sim:current,data}, null, 2);
  };
  el.copyPreset.onclick=()=>{
    navigator.clipboard.writeText(el.presetJson.value||'').catch(()=>{});
  };

  // Rendering loop
  let last=performance.now(), acc=0, fpsC=0, fpsT=0;
  function stepFrame(dt){
    sim.step(dt);
  }
  function render(){
    const now=performance.now(); let dt=(now-last)/1000; last=now;
    fpsT+=dt; fpsC++; if(fpsT>=0.5){ el.fps.textContent = (fpsC/fpsT|0); fpsC=0; fpsT=0; }
    if(running){
      acc += dt*speed; // fixed step
      while(acc>1/60){ stepFrame(1/60); acc-=1/60; }
    }
    sim.draw();
    el.statA.textContent=sim.statsA|0;
    el.tick.textContent=sim.tick|0;
    requestAnimationFrame(render);
  }

  // Init
  buildSceneList();
  selectScene(0);
  markActive(0);
  resize();
  window.addEventListener('keydown', e=>{
    if(e.code==='Space'){ e.preventDefault(); el.playPause.click(); }
  });

  // First paint
  requestAnimationFrame(render);
})();
</script>
</body>
</html>